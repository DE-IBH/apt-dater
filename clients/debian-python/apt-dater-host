#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
apt-dater-host - Provding apt-dater with information about the host
"""
# Copyright (C) 2008 Sebastian Heinlein <devel@glatzor.de>
# Copyright (C) 2008-2009 IBH IT-Service GmbH [http://www.ibh.de/apt-dater/]
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

__author__  = "Sebastian Heinlein <devel@glatzor.de>"

from ConfigParser import ConfigParser
import os
import re
import sys
import subprocess
import warnings

# There have been some API changes in python-apt recently
warnings.filterwarnings("ignore", category=FutureWarning)
warnings.filterwarnings("ignore", category=DeprecationWarning)

import apt
import apt_pkg

KERNEL_LATEST = 0   # Running kernel is the latest installed one
KERNEL_REBOOT = 1   # Later kernel than the running one is installed
KERNEL_CUSTOM = 2   # Custom kernel is installed
KERNEL_UNKOWN = 9   # Unkown kernel is installed

ADPROTO = "0.3"

FORBID_NONE = 0
FORBID_REFRESH = 1
FORBID_UPGRADE = 2
FORBID_INSTALL = 4

class DebianAptDaterHost(object):
    """Provides a Debian client for apt-dater."""
    def __init__(self):
        self.dist = "Unkown"
        self.dist_release = "Unkown"
        self.dist_codename = "Unkown"
        self.system = "Unkown"
        self.machine = "Unkown"
        self.kernel_release = "Unkown"
        self.virtual = "Unkown"
        self._cache = None
        self._collect_sys_info()
        self._parse_config()

    def kernel(self):
        """Send information about the running kernel."""
        self._emit_proto()
        self._init_cache()
        try:
            ver_file = open("/proc/version")
            ver_out = ver_file.read()
            ver_out.close()
        except:
            self._emit_kernel_info(KERNEL_UNKOWN, self.kernel_release)
            return
        # Is the kernel provided by the distro?
        match = re.match("^\S+? \S+? \S+? \(%s (\S+?)\)" % self.dist, ver_out)
        if match is None:
            self._emit_kernel_info(KERNEL_CUSTOM, self.kernel_release)
            return
        # Is there a later kernel version than the running one installed?
        version = match.group(1)
        for pkg in self._cache:
            if pkg.isInstalled and \
               re.match("^linux-image-[0-9]\.[0-9]\.[0-9]+-[0-9]+-[a-z0-9-]+$",
                        pkg.name) is not None and \
               apt_pkg.VersionCompare(pkg.installedVersion, version) > 0:
                self._emit_kernel_info(KERNEL_REBOOT, self.kernel_release)
                return
        self._emit_kernel_info(KERNEL_LATEST, self.kernel_release)

    def status(self):
        """Send status information about the system."""
        self._emit_proto()
        self._init_cache()
        # Send status of installed packages
        self._cache.upgrade()
        for pkg in self._cache:
            if not pkg.isInstalled:
                continue
            if pkg.isUpgradable:
                if pkg.markedUpgrade and not \
                   self._cache._depcache.IsNowBroken(pkg._pkg):
                    status = "u=%s" % pkg.candidateVersion
                else:
                    status = "h"
            elif not pkg.candidateDownloadable:
                status = "x"
            elif self._cache._depcache.IsInstBroken(pkg._pkg):
                status = "b"
            else:
                status = "i"
            self._emit_status(pkg.name, pkg.installedVersion, status)
        # Send which actions are forbidden
        mask = FORBID_NONE
        if self._config.getboolean("apt-dater", "forbid_install"):
            mask |= FORBID_INSTALL
        if self._config.getboolean("apt-dater", "forbid_upgrade"):
            mask |= FORBID_UPGRADE
        if self._config.getboolean("apt-dater", "forbid_refresh"):
            mask |= FORBID_REFRESH
        self._emit_forbidden(mask)
        # Send further information
        self._emit_virtual(self.virtual)
        self._emit_lsb_info(self.dist, self.dist_release, self.dist_codename)
        self._emit_uname_info(self.system, self.machine)

    def refresh(self):
        """Query for new or later software."""
        if self._config.getboolean("apt-dater", "forbid_refresh"):
            self._emit_error("It isn't allowed to refresh the host.")
            return
        self._call_frontend(["update"])

    def upgrade(self):
        """Upgrade the software on the system."""
        if self._config.getboolean("apt-dater", "forbid_upgrade"):
            self._emit_error("It isn't allowed to upgrade the host.")
            return
        if os.path.basename(self._config.get("dpkg", "frontend")) == "aptitude":
            self._call_frontend(["safe-upgrade"])
        else:
            self._call_frontend(["upgrade"])
        if self._config.getboolean("dpkg", "clean"):
            self._call_frontend(["clean"])

    def install(self, packages):
        """Install the given packages on the system."""
        if self._config.getboolean("apt-dater", "forbid_install"):
            self._emit_error("It isn't allowed to install packages "
                             "on this host.")
            return
        args = ["install"]
        args.extend(packages)
        self._call_frontend(args)
        if self._config.getboolean("dpkg", "clean"):
            self._call_frontend(["clean"])

    def _init_cache(self):
        """Initialize the APT cache or reset it if already existing."""
        if self._cache is None:
            self._cache = apt.Cache()
        else:
            self._cache._depcache.Init()

    def _parse_config(self):
        """Set defaults and read the configuration from file."""
        self._config = ConfigParser()
        self._config.add_section("dpkg")
        self._config.set("dpkg", "frontend", "/usr/bin/apt-get")
        self._config.set("dpkg", "root_cmd", "/usr/bin/sudo")
        self._config.set("dpkg", "clean", "False")
        self._config.add_section("apt-dater")
        self._config.set("apt-dater", "forbid_refresh", "False")
        self._config.set("apt-dater", "forbid_upgrade", "False")
        self._config.set("apt-dater", "forbid_install", "False")
        self._config.read(["apt-dater-host.conf", "/etc/apt-dater-host.conf"])

    def _collect_sys_info(self):
        """Collect information about the system."""
        self.system, host, self.kernel_release, ver, self.machine = os.uname()
        try:
            lsb_out = subprocess.Popen(["lsb_release", "--short", "--id",
                                        "--codename", "--release"],
                                       stdout=subprocess.PIPE).stdout.read()
            self.dist, self.dist_codename, self.dist_release = lsb_out.split()
        except:
            pass
        try:
            out = subprocess.Popen(["imvirt"],
                                   stdout=subprocess.PIPE).stdout.read()
            self.virtual = out.strip()
        except:
            pass

    def _call_frontend(self, args):
        """Run the dpkg frontend with the given arguments."""
        command = [self._config.get("dpkg", "root_cmd"),
                   self._config.get("dpkg", "frontend"),
                   "--"]
        command.extend(args)
        try:
            ret = subprocess.call(command)
            if ret > 0:
                self._emit_error("Frontend was terminated with %s" % ret)
        except OSError, e:
            self._emit_error("Frontend failed: %s" % e)

    def _emit_error(self, message):
        """Emit a message to stderr."""
        print >> sys.stderr, "ERROR: %s" % message
        sys.stdout.flush()
        sys.stderr.flush()

    def _emit_forbidden(self, mask):
        """Emit FORBID signal."""
        print >> sys.stdout, "FORBID: %s" % mask
        sys.stdout.flush()

    def _emit_status(self, name, version, status):
        """Emit STATUS signal."""
        print >> sys.stdout, "STATUS: %s|%s|%s" % (name, version, status)
        sys.stdout.flush()

    def _emit_uname_info(self, system, machine):
        """Emit UNAME signal."""
        print >> sys.stdout, "UNAME: %s|%s" % (system, machine)
        sys.stdout.flush()

    def _emit_kernel_info(self, status, version):
        """Emit KERNELINFO signal."""
        print >> sys.stdout, "KERNELINFO: %s %s" % (status, version)
        sys.stdout.flush()

    def _emit_lsb_info(self, distro, release, codename):
        """Emit LSBREL signal."""
        print >> sys.stdout, "LSBREL: %s|%s|%s" % (distro, release, codename)
        sys.stdout.flush()

    def _emit_virtual(self, virtual):
        """Emit VIRT signal."""
        print >> sys.stdout, "VIRT: %s" % virtual
        sys.stdout.flush()

    def _emit_proto(self):
        """Emit ADPROTO signal."""
        print >> sys.stdout, "ADPROTO: %s" % ADPROTO
        sys.stdout.flush()


def main():
    if len(sys.argv) == 0:
        print("Do not run this script directly")
        sys.exit(1)
    command = sys.argv[1]
    host = DebianAptDaterHost()
    if command == "status":
        host.status()
        host.kernel()
    if command == "kernel":
        host.kernel()
    if command == "refresh":
        host.refresh()
        host.status()
        host.kernel()
    if command == "upgrade":
        host.upgrade()
    if command == "install":
        host.install(sys.argv[2:])

if __name__ == "__main__":
    main()

# vim:ts=4:sw=4:et
